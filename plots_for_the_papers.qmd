---
title: "Plots for the papers"
author: "Tzu-Yao Lin"
date: last-modified
bibliography: bibliography.bib
csl: apa.csl
execute:
  eval: true
  warning: false
  cache: true
format: 
  html:
    toc: true
    toc-depth: 3
    number-sections: true
    self-contained: true
    code-fold: true
    code-tools: true
---


# Setup

Load necessary packages.

```{r}
#| label: setup
 
library(tidyverse)
theme_set(theme_bw() + 
          theme(aspect.ratio = 1))
library(furrr)
plan(multisession, workers = 8)
library(irr)
library(psych)
library(gt)
set.seed(20260209)
```


## ICC Simulation Function

```{r}
#| label: icc-cor-funcs

oneway_icc <- function(pars, 
                       unit = c("single", "average"),
                       rep_size = 1000) {
  if (is.null(pars$mu)) {mu <- 0} else {mu <- pars$mu}
  if (is.null(pars$sigma_S)) {stop("sigma_S need to be specified")}
  if (is.null(pars$sigma_E)) {stop("sigma_E need to be specified")}
  if (is.null(pars$k)) {stop("k need to be specified")}
  
  sigma_S <- pars$sigma_S
  sigma_E <- pars$sigma_E 
  k <- pars$k
  num_ave_R <- ifelse(unit == "single", 1, k)
  
  # 
  y_ij1 <- vector("double", length = rep_size)
  y_ij2 <- vector("double", length = rep_size)
  
  for (l in seq_len(rep_size)) {
    S_i <- rnorm(1, 0, sigma_S)
    E_ij1 <- rnorm(num_ave_R, 0, sigma_E)
    E_ij2 <- rnorm(num_ave_R, 0, sigma_E)
    y_ij1[l] <- mu + S_i + mean(E_ij1)
    y_ij2[l] <- mu + S_i + mean(E_ij2)
  }

  return(cor(y_ij1, y_ij2))
}

twoway_random_icc <- function(pars,
                              type = c("agreement", "consistency"),
                              unit = c("single", "average"),
                              rep_size = 1000) {

  if (is.null(pars$mu)) {mu <- 0} else {mu <- pars$mu}
  if (is.null(pars$sigma_S)) {stop("sigma_S need to be specified")}
  if (is.null(pars$sigma_R)) {stop("sigma_R need to be specified")}
  if (is.null(pars$sigma_E)) {stop("sigma_E need to be specified")}
  if (is.null(pars$k)) {stop("k need to be specified")}
  
  sigma_S <- pars$sigma_S
  sigma_E <- pars$sigma_E
  sigma_R <- pars$sigma_R 
  k <- pars$k
  num_ave_R <- ifelse(unit == "single", 1, k)
  
  # 
  y_ij1 <- vector("double", length = rep_size)
  y_ij2 <- vector("double", length = rep_size)

  if (type == "agreement") {
    for (l in seq_len(rep_size)) {
      S_i <- rnorm(1, 0, sigma_S)
      R_j1 <- rnorm(num_ave_R, 0, sigma_R)
      R_j2 <- rnorm(num_ave_R, 0, sigma_R)
      E_ij1 <- rnorm(num_ave_R, 0, sigma_E)
      E_ij2 <- rnorm(num_ave_R, 0, sigma_E)
      y_ij1[l] <- mu + S_i + mean(R_j1) + mean(E_ij1)
      y_ij2[l] <- mu + S_i + mean(R_j2) + mean(E_ij2)
    }
  } else if (type == "consistency") {
    # rater effects are fixed across measurements
    R_j1 <- rnorm(num_ave_R, 0, sigma_R)
    R_j2 <- rnorm(num_ave_R, 0, sigma_R)
    
    # other random effects are independently generated
    for (l in seq_len(rep_size)) {
      S_i <- rnorm(1, 0, sigma_S)
      E_ij1 <- rnorm(num_ave_R, 0, sigma_E)
      E_ij2 <- rnorm(num_ave_R, 0, sigma_E)
      y_ij1[l] <- mu + S_i + mean(R_j1) + mean(E_ij1)
      y_ij2[l] <- mu + S_i + mean(R_j2) + mean(E_ij2)
    }
  }
  
  return(cor(y_ij1, y_ij2))
}

twoway_mixed_icc <- function(pars, 
                             type = c("agreement", "consistency"),
                             unit = c("single", "average"),
                             rep_size = 1000) {
  if (is.null(pars$mu)) {mu <- 0} else {mu <- pars$mu}
  if (is.null(pars$sigma_S)) {stop("sigma_S need to be specified")}
  if (is.null(pars$theta_R)) {stop("theta_R need to be specified")}
  if (is.null(pars$sigma_E)) {stop("sigma_E need to be specified")}
  if (is.null(pars$k)) {stop("k need to be specified")}
  
  sigma_S <- pars$sigma_S
  theta_R <- pars$theta_R 
  sigma_E <- pars$sigma_E
  k <- pars$k
  num_ave_R <- ifelse(unit == "single", 1, k)
  
  # 
  y_ij1 <- vector("double", length = rep_size)
  y_ij2 <- vector("double", length = rep_size)

  # rater effects are fixed in all scenarios
  R_j <- MASS::mvrnorm(k, 0, theta_R^2, empirical = TRUE) |> as.vector()
  
  if (type == "agreement") {
    
    for (l in seq_len(rep_size)) {
      if (unit == "single") {
        selected_R_j1j2 <- sample(k, 2, replace = FALSE)
      } else {
        selected_R_j1j2 <- 1:k # actually, everyone have the same group of raters, Ak == Ck
      }
      S_i <- rnorm(1, 0, sigma_S)
      R_j1 <- R_j[selected_R_j1j2[1]]
      R_j2 <- R_j[selected_R_j1j2[2]]
      E_ij1 <- rnorm(num_ave_R, 0, sigma_E)
      E_ij2 <- rnorm(num_ave_R, 0, sigma_E)
      y_ij1[l] <- mu + S_i + mean(R_j1) + mean(E_ij1)
      y_ij2[l] <- mu + S_i + mean(R_j2) + mean(E_ij2)
    }
  } else if (type == "consistency") {
    # rater effects are fixed across measurements
    if (unit == "single") {
      selected_R_j1j2 <- sample(k, 2, replace = FALSE)
    } else {
      selected_R_j1j2 <- 1:k # actually, everyone have the same group of raters, Ak == Ck
    }
    
    R_j1 <- R_j[selected_R_j1j2[1]]
    R_j2 <- R_j[selected_R_j1j2[2]]
    
    # other random effects are independently generated
    for (l in seq_len(rep_size)) {
      S_i <- rnorm(1, 0, sigma_S)
      E_ij1 <- rnorm(num_ave_R, 0, sigma_E)
      E_ij2 <- rnorm(num_ave_R, 0, sigma_E)
      y_ij1[l] <- mu + S_i + mean(R_j1) + mean(E_ij1)
      y_ij2[l] <- mu + S_i + mean(R_j2) + mean(E_ij2)
    }
  }

  return(cor(y_ij1, y_ij2))
}


```


```{r}
#| label: wrapper-icc-cor-func
 
icc_cor <- function(pars, 
                    model = c("oneway", "twoway-random", "twoway-mixed"),
                    type = c("agreement", "consistency"),
                    unit = c("single", "average"),
                    rep_size = 10000) {
  model <- match.arg(model)
  type <- match.arg(type)
  unit <- match.arg(unit)

  icc <- switch(model, 
    "oneway" = oneway_icc(pars, unit, rep_size),
    "twoway-random" = twoway_random_icc(pars, type, unit, rep_size),
    "twoway-mixed" = twoway_mixed_icc(pars, type, unit, rep_size),
  )

  return(icc)
}
```



# Case 1: One-Way Random-Effect ANOVA

```{r}
#| label: case1-icc-sim

rep_size <- 10000
sigma_E <- 10
sigma_SE_ratio <- c(0.1, 0.2, 0.5, 1, 2, 5, 10)
k <- 5

case1_sim_data <- 
  expand_grid(
    rep_size = rep_size,
    sigma_E = sigma_E,
    sigma_SE_ratio = sigma_SE_ratio,
    k = k
  ) |>
  mutate(
    sigma_S = sigma_SE_ratio * sigma_E, 
    pars = list_transpose(list(sigma_S = sigma_S, sigma_E = sigma_E, k = k), 
                          simplify = FALSE),
    pop_icc_1 = sigma_S^2 / (sigma_S^2 + sigma_E^2),
    pop_icc_k = sigma_S^2 / (sigma_S^2 + sigma_E^2 / k), 
    sim_icc_1 = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "oneway", unit = "single", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ), 
    sim_icc_k = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "oneway", unit = "average", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    )
  ) |> 
  pivot_longer(cols = c(pop_icc_1, sim_icc_1, pop_icc_k, sim_icc_k), 
               names_to = "name", values_to = "value") |> 
  mutate(
    form = case_when(
      str_detect(name, "pop") ~ "Population",
      str_detect(name, "sim") ~ "Simulation"
    ),
    unit = case_when(
      str_detect(name, "_1") ~ "Single",
      str_detect(name, "_k") ~ "Average"
    )
  ) 

View(case1_sim_data)

```

```{r}
#| label: fig-case1-icc
#| fig-cap: "ICC(1)"

case1_sim_data |> 
  ggplot(aes(x = sigma_SE_ratio, y = value, shape = form, color = unit)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  labs(x = "sigma_S / sigma_E", y = "ICC(1)", shape = "Type", color = "Unit") 


```


# Case 2: Two-Way Random-Effect ANOVA


```{r}
#| label: case2-icc-sim
 
rep_size <- 10000
sigma_E <- c(1, 3, 5)
sigma_SE_ratio <- c(0.1, 0.2, 0.5, 1, 2, 5, 10)
sigma_RE_ratio <- c(0.1, 0.2, 0.5, 1, 2, 5, 10)
k <- 5

case2_sim_data <- 
  expand_grid(
    rep_size = rep_size,
    sigma_E = sigma_E,
    sigma_SE_ratio = sigma_SE_ratio,
    sigma_RE_ratio = sigma_RE_ratio,
    k = k
  ) |>
  mutate(
    sigma_S = sigma_SE_ratio * sigma_E, 
    sigma_R = sigma_RE_ratio * sigma_E,
    pars = list_transpose(list(sigma_S = sigma_S, sigma_R = sigma_R, sigma_E = sigma_E, k = k),
                          simplify = FALSE),
    pop_icc_A1 = sigma_S^2 / (sigma_S^2 + sigma_R^2 + sigma_E^2),
    pop_icc_Ak = sigma_S^2 / (sigma_S^2 + sigma_R^2 / k + sigma_E^2 / k),
    pop_icc_C1 = sigma_S^2 / (sigma_S^2 + sigma_E^2),
    pop_icc_Ck = sigma_S^2 / (sigma_S^2 + sigma_E^2 / k), 
    sim_icc_A1 = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-random", type = "agreement",unit = "single", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ), 
    sim_icc_Ak = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-random", type = "agreement", unit = "average", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ),
    sim_icc_C1 = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-random", type = "consistency", unit = "single", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ), 
    sim_icc_Ck = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-random", type = "consistency",unit = "average", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    )
  ) |> 
  pivot_longer(cols = c(pop_icc_A1, pop_icc_Ak, pop_icc_C1, pop_icc_Ck, 
                        sim_icc_A1, sim_icc_Ak, sim_icc_C1, sim_icc_Ck), 
               names_to = "name", values_to = "value") |> 
  mutate(
    form = case_when(
      str_detect(name, "pop") ~ "Population",
      str_detect(name, "sim") ~ "Simulation"
    ),
    unit = case_when(
      str_detect(name, "1") ~ "Single",
      str_detect(name, "k") ~ "Average"
    ),
    type = case_when(
      str_detect(name, "A") ~ "Agreement",
      str_detect(name, "C") ~ "Consistency"
    )
  ) 

View(case2_sim_data)

```


```{r}

case2_sim_data |> 
  filter(type == "Agreement") |>
  ggplot(aes(x = sigma_SE_ratio, y = value, shape = form, color = unit)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  labs(x = "sigma_S / sigma_E", y = "ICC(1)", shape = "Type", color = "Unit") +
  facet_wrap(~ sigma_RE_ratio, nrow = 2)

```


```{r}
case2_sim_data |> 
  filter(type == "Consistency") |>
  ggplot(aes(x = sigma_SE_ratio, y = value, shape = form, color = unit)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  labs(x = "sigma_S / sigma_E", y = "ICC(1)", shape = "Type", color = "Unit") +
  facet_wrap(~ sigma_RE_ratio, nrow = 2)

```



# Case 3: Two-Way Mixed-Effect ANOVA


```{r}
#| label: case3-icc-sim

rep_size <- 10000
sigma_E <- c(1, 3, 5)
sigma_SE_ratio <- c(0.1, 0.2, 0.5, 1, 2, 5, 10)
sigma_RE_ratio <- c(0.1, 0.2, 0.5, 1, 2, 5, 10)
k <- 5

case3_sim_data <- 
  expand_grid(
    rep_size = rep_size,
    sigma_E = sigma_E,
    sigma_SE_ratio = sigma_SE_ratio,
    sigma_RE_ratio = sigma_RE_ratio,
    k = k
  ) |>
  mutate(
    sigma_S = sigma_SE_ratio * sigma_E, 
    theta_R = sigma_RE_ratio * sigma_E,
    pars = list_transpose(list(sigma_S = sigma_S, theta_R = theta_R, sigma_E = sigma_E, k = k), simplify = FALSE),
    pop_icc_A1 = sigma_S^2 / (sigma_S^2 + theta_R^2 + sigma_E^2),
    pop_icc_Ak = sigma_S^2 / (sigma_S^2 + theta_R^2 / k + sigma_E^2 / k),
    pop_corrected_icc_A1 = (sigma_S^2 - theta_R^2 / (k-1)) / (sigma_S^2 + theta_R^2 + sigma_E^2),
    pop_corrected_icc_Ak = sigma_S^2 / (sigma_S^2 + sigma_E^2 / k),
    pop_icc_C1 = sigma_S^2 / (sigma_S^2 + sigma_E^2),
    pop_icc_Ck = sigma_S^2 / (sigma_S^2 + sigma_E^2 / k), 
    sim_icc_A1 = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-mixed", type = "agreement",unit = "single", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ), 
    sim_icc_Ak = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-mixed", type = "agreement", unit = "average", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ),
    sim_icc_C1 = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-mixed", type = "consistency", unit = "single", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    ), 
    sim_icc_Ck = future_map2_dbl(
      pars, rep_size,
      ~ icc_cor(pars = .x, model = "twoway-mixed", type = "consistency",unit = "average", rep_size = .y),
      .options = furrr_options(seed = TRUE)
    )
  ) |> 
  pivot_longer(cols = c(pop_icc_A1, pop_icc_Ak, pop_corrected_icc_A1, pop_corrected_icc_Ak,
                        pop_icc_C1, pop_icc_Ck, 
                        sim_icc_A1, sim_icc_Ak, sim_icc_C1, sim_icc_Ck), 
               names_to = "name", values_to = "value") |> 
  mutate(
    form = case_when(
      str_detect(name, "pop_icc") ~ "Population",
      str_detect(name, "pop_corrected") ~ "Population (corrected)",
      str_detect(name, "sim") ~ "Simulation"
    ),
    unit = case_when(
      str_detect(name, "1") ~ "Single",
      str_detect(name, "k") ~ "Average"
    ),
    type = case_when(
      str_detect(name, "A") ~ "Agreement",
      str_detect(name, "C") ~ "Consistency"
    )
  ) 

View(case3_sim_data)

```


```{r}
case3_sim_data |> 
  filter(type == "Agreement") |>
  ggplot(aes(x = sigma_SE_ratio, y = value, shape = form, color = unit)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  labs(x = "sigma_S / sigma_E", y = "ICC(1)", shape = "Form", color = "Unit") +
  facet_wrap(~ sigma_RE_ratio, nrow = 2)

```




```{r}
case3_sim_data |> 
  filter(type == "Consistency") |>
  ggplot(aes(x = sigma_SE_ratio, y = value, group = form, shape = form, color = unit)) +
  geom_line() +
  geom_point() +
  scale_x_log10() +
  labs(x = "sigma_S / sigma_E", y = "ICC(1)", shape = "Form", color = "Unit") +
  facet_wrap(~ sigma_RE_ratio, nrow = 2)
```



